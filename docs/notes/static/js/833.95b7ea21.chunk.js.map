{"version":3,"file":"static/js/833.95b7ea21.chunk.js","mappings":"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","sources":["../node_modules/@firebase/installations/src/util/constants.ts","../node_modules/@firebase/installations/src/util/errors.ts","../node_modules/@firebase/installations/src/api/common.ts","../node_modules/@firebase/installations/src/api/create-installation-request.ts","../node_modules/@firebase/installations/src/util/sleep.ts","../node_modules/@firebase/installations/src/helpers/generate-fid.ts","../node_modules/@firebase/installations/src/helpers/buffer-to-base64-url-safe.ts","../node_modules/@firebase/installations/src/util/get-key.ts","../node_modules/@firebase/installations/src/helpers/fid-changed.ts","../node_modules/@firebase/installations/src/helpers/idb-manager.ts","../node_modules/@firebase/installations/src/index.ts","../node_modules/@firebase/installations/src/helpers/get-installation-entry.ts","../node_modules/@firebase/installations/src/api/generate-auth-token-request.ts","../node_modules/@firebase/installations/src/helpers/refresh-auth-token.ts","../node_modules/@firebase/installations/src/functions/get-token.ts","../node_modules/@firebase/installations/src/api/delete-installation-request.ts","../node_modules/@firebase/installations/src/functions/on-id-change.ts","../node_modules/@firebase/installations/src/helpers/extract-app-config.ts","../node_modules/@firebase/installations/src/functions/get-id.ts","../node_modules/@firebase/installations/src/functions/delete-installation.ts","../node_modules/idb/build/idb.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { version } from '../../package.json';\n\nexport const PENDING_TIMEOUT_MS = 10000;\n\nexport const PACKAGE_VERSION = `w:${version}`;\nexport const INTERNAL_AUTH_VERSION = 'FIS_v2';\n\nexport const INSTALLATIONS_API_URL =\n  'https://firebaseinstallations.googleapis.com/v1';\n\nexport const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\n\nexport const SERVICE = 'installations';\nexport const SERVICE_NAME = 'Installations';\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { SERVICE, SERVICE_NAME } from './constants';\n\nexport const enum ErrorCode {\n  MISSING_APP_CONFIG_VALUES = 'missing-app-config-values',\n  NOT_REGISTERED = 'not-registered',\n  INSTALLATION_NOT_FOUND = 'installation-not-found',\n  REQUEST_FAILED = 'request-failed',\n  APP_OFFLINE = 'app-offline',\n  DELETE_PENDING_REGISTRATION = 'delete-pending-registration'\n}\n\nconst ERROR_DESCRIPTION_MAP: { readonly [key in ErrorCode]: string } = {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]:\n    'Missing App configuration value: \"{$valueName}\"',\n  [ErrorCode.NOT_REGISTERED]: 'Firebase Installation is not registered.',\n  [ErrorCode.INSTALLATION_NOT_FOUND]: 'Firebase Installation not found.',\n  [ErrorCode.REQUEST_FAILED]:\n    '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n  [ErrorCode.APP_OFFLINE]: 'Could not process request. Application offline.',\n  [ErrorCode.DELETE_PENDING_REGISTRATION]:\n    \"Can't delete installation while there is a pending registration request.\"\n};\n\ninterface ErrorParams {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]: {\n    valueName: string;\n  };\n  [ErrorCode.REQUEST_FAILED]: {\n    requestName: string;\n    [index: string]: string | number; // to make Typescript 3.8 happy\n  } & ServerErrorData;\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<ErrorCode, ErrorParams>(\n  SERVICE,\n  SERVICE_NAME,\n  ERROR_DESCRIPTION_MAP\n);\n\nexport interface ServerErrorData {\n  serverCode: number;\n  serverMessage: string;\n  serverStatus: string;\n}\n\nexport type ServerError = FirebaseError & { customData: ServerErrorData };\n\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\nexport function isServerError(error: unknown): error is ServerError {\n  return (\n    error instanceof FirebaseError &&\n    error.code.includes(ErrorCode.REQUEST_FAILED)\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport {\n  INSTALLATIONS_API_URL,\n  INTERNAL_AUTH_VERSION\n} from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function getInstallationsEndpoint({ projectId }: AppConfig): string {\n  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\n}\n\nexport function extractAuthTokenInfoFromResponse(\n  response: GenerateAuthTokenResponse\n): CompletedAuthToken {\n  return {\n    token: response.token,\n    requestStatus: RequestStatus.COMPLETED,\n    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n    creationTime: Date.now()\n  };\n}\n\nexport async function getErrorFromResponse(\n  requestName: string,\n  response: Response\n): Promise<FirebaseError> {\n  const responseJson: ErrorResponse = await response.json();\n  const errorData = responseJson.error;\n  return ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {\n    requestName,\n    serverCode: errorData.code,\n    serverMessage: errorData.message,\n    serverStatus: errorData.status\n  });\n}\n\nexport function getHeaders({ apiKey }: AppConfig): Headers {\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n\nexport function getHeadersWithAuth(\n  appConfig: AppConfig,\n  { refreshToken }: RegisteredInstallationEntry\n): Headers {\n  const headers = getHeaders(appConfig);\n  headers.append('Authorization', getAuthorizationHeader(refreshToken));\n  return headers;\n}\n\nexport interface ErrorResponse {\n  error: {\n    code: number;\n    message: string;\n    status: string;\n  };\n}\n\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */\nexport async function retryIfServerError(\n  fn: () => Promise<Response>\n): Promise<Response> {\n  const result = await fn();\n\n  if (result.status >= 500 && result.status < 600) {\n    // Internal Server Error. Retry request.\n    return fn();\n  }\n\n  return result;\n}\n\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn: string): number {\n  // This works because the server will never respond with fractions of a second.\n  return Number(responseExpiresIn.replace('s', '000'));\n}\n\nfunction getAuthorizationHeader(refreshToken: string): string {\n  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CreateInstallationResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { INTERNAL_AUTH_VERSION, PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeaders,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function createInstallationRequest(\n  appConfig: AppConfig,\n  { fid }: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  const endpoint = getInstallationsEndpoint(appConfig);\n\n  const headers = getHeaders(appConfig);\n  const body = {\n    fid,\n    authVersion: INTERNAL_AUTH_VERSION,\n    appId: appConfig.appId,\n    sdkVersion: PACKAGE_VERSION\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: CreateInstallationResponse = await response.json();\n    const registeredInstallationEntry: RegisteredInstallationEntry = {\n      fid: responseValue.fid || fid,\n      registrationStatus: RequestStatus.COMPLETED,\n      refreshToken: responseValue.refreshToken,\n      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n    };\n    return registeredInstallationEntry;\n  } else {\n    throw await getErrorFromResponse('Create Installation', response);\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Returns a promise that resolves after given time passes. */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bufferToBase64UrlSafe } from './buffer-to-base64-url-safe';\n\nexport const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nexport const INVALID_FID = '';\n\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */\nexport function generateFid(): string {\n  try {\n    // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n    // bytes. our implementation generates a 17 byte array instead.\n    const fidByteArray = new Uint8Array(17);\n    const crypto =\n      self.crypto || ((self as unknown) as { msCrypto: Crypto }).msCrypto;\n    crypto.getRandomValues(fidByteArray);\n\n    // Replace the first 4 random bits with the constant FID header of 0b0111.\n    fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n\n    const fid = encode(fidByteArray);\n\n    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n  } catch {\n    // FID generation errored\n    return INVALID_FID;\n  }\n}\n\n/** Converts a FID Uint8Array to a base64 string representation. */\nfunction encode(fidByteArray: Uint8Array): string {\n  const b64String = bufferToBase64UrlSafe(fidByteArray);\n\n  // Remove the 23rd character that was added because of the extra 4 bits at the\n  // end of our 17 byte array, and the '=' padding.\n  return b64String.substr(0, 22);\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function bufferToBase64UrlSafe(array: Uint8Array): string {\n  const b64 = btoa(String.fromCharCode(...array));\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\n\n/** Returns a string key that can be used to identify the app. */\nexport function getKey(appConfig: AppConfig): string {\n  return `${appConfig.appName}!${appConfig.appId}`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getKey } from '../util/get-key';\nimport { AppConfig } from '../interfaces/app-config';\nimport { IdChangeCallbackFn } from '../functions';\n\nconst fidChangeCallbacks: Map<string, Set<IdChangeCallbackFn>> = new Map();\n\n/**\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\n * change to other tabs.\n */\nexport function fidChanged(appConfig: AppConfig, fid: string): void {\n  const key = getKey(appConfig);\n\n  callFidChangeCallbacks(key, fid);\n  broadcastFidChange(key, fid);\n}\n\nexport function addCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  // Open the broadcast channel if it's not already open,\n  // to be able to listen to change events from other tabs.\n  getBroadcastChannel();\n\n  const key = getKey(appConfig);\n\n  let callbackSet = fidChangeCallbacks.get(key);\n  if (!callbackSet) {\n    callbackSet = new Set();\n    fidChangeCallbacks.set(key, callbackSet);\n  }\n  callbackSet.add(callback);\n}\n\nexport function removeCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  const key = getKey(appConfig);\n\n  const callbackSet = fidChangeCallbacks.get(key);\n\n  if (!callbackSet) {\n    return;\n  }\n\n  callbackSet.delete(callback);\n  if (callbackSet.size === 0) {\n    fidChangeCallbacks.delete(key);\n  }\n\n  // Close broadcast channel if there are no more callbacks.\n  closeBroadcastChannel();\n}\n\nfunction callFidChangeCallbacks(key: string, fid: string): void {\n  const callbacks = fidChangeCallbacks.get(key);\n  if (!callbacks) {\n    return;\n  }\n\n  for (const callback of callbacks) {\n    callback(fid);\n  }\n}\n\nfunction broadcastFidChange(key: string, fid: string): void {\n  const channel = getBroadcastChannel();\n  if (channel) {\n    channel.postMessage({ key, fid });\n  }\n  closeBroadcastChannel();\n}\n\nlet broadcastChannel: BroadcastChannel | null = null;\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\nfunction getBroadcastChannel(): BroadcastChannel | null {\n  if (!broadcastChannel && 'BroadcastChannel' in self) {\n    broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\n    broadcastChannel.onmessage = e => {\n      callFidChangeCallbacks(e.data.key, e.data.fid);\n    };\n  }\n  return broadcastChannel;\n}\n\nfunction closeBroadcastChannel(): void {\n  if (fidChangeCallbacks.size === 0 && broadcastChannel) {\n    broadcastChannel.close();\n    broadcastChannel = null;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DB, openDb } from 'idb';\nimport { AppConfig } from '../interfaces/app-config';\nimport { InstallationEntry } from '../interfaces/installation-entry';\nimport { getKey } from '../util/get-key';\nimport { fidChanged } from './fid-changed';\n\nconst DATABASE_NAME = 'firebase-installations-database';\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\n\nlet dbPromise: Promise<DB> | null = null;\nfunction getDbPromise(): Promise<DB> {\n  if (!dbPromise) {\n    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, upgradeDB => {\n      // We don't use 'break' in this switch statement, the fall-through\n      // behavior is what we want, because if there are multiple versions between\n      // the old version and the current version, we want ALL the migrations\n      // that correspond to those versions to run, not only the last one.\n      // eslint-disable-next-line default-case\n      switch (upgradeDB.oldVersion) {\n        case 0:\n          upgradeDB.createObjectStore(OBJECT_STORE_NAME);\n      }\n    });\n  }\n  return dbPromise;\n}\n\n/** Gets record(s) from the objectStore that match the given key. */\nexport async function get(\n  appConfig: AppConfig\n): Promise<InstallationEntry | undefined> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  return db\n    .transaction(OBJECT_STORE_NAME)\n    .objectStore(OBJECT_STORE_NAME)\n    .get(key);\n}\n\n/** Assigns or overwrites the record for the given key with the given value. */\nexport async function set<ValueType extends InstallationEntry>(\n  appConfig: AppConfig,\n  value: ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const objectStore = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue = await objectStore.get(key);\n  await objectStore.put(value, key);\n  await tx.complete;\n\n  if (!oldValue || oldValue.fid !== value.fid) {\n    fidChanged(appConfig, value.fid);\n  }\n\n  return value;\n}\n\n/** Removes record(s) from the objectStore that match the given key. */\nexport async function remove(appConfig: AppConfig): Promise<void> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n  await tx.complete;\n}\n\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */\nexport async function update<ValueType extends InstallationEntry | undefined>(\n  appConfig: AppConfig,\n  updateFn: (previousValue: InstallationEntry | undefined) => ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const store = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue: InstallationEntry | undefined = await store.get(key);\n  const newValue = updateFn(oldValue);\n\n  if (newValue === undefined) {\n    await store.delete(key);\n  } else {\n    await store.put(newValue, key);\n  }\n  await tx.complete;\n\n  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\n    fidChanged(appConfig, newValue.fid);\n  }\n\n  return newValue;\n}\n\nexport async function clear(): Promise<void> {\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).clear();\n  await tx.complete;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport {\n  _FirebaseNamespace,\n  FirebaseService\n} from '@firebase/app-types/private';\nimport { Component, ComponentType } from '@firebase/component';\nimport { FirebaseInstallations } from '@firebase/installations-types';\nimport {\n  deleteInstallation,\n  getId,\n  getToken,\n  IdChangeCallbackFn,\n  IdChangeUnsubscribeFn,\n  onIdChange\n} from './functions';\nimport { extractAppConfig } from './helpers/extract-app-config';\nimport { FirebaseDependencies } from './interfaces/firebase-dependencies';\n\nimport { name, version } from '../package.json';\n\nexport function registerInstallations(instance: _FirebaseNamespace): void {\n  const installationsName = 'installations';\n\n  instance.INTERNAL.registerComponent(\n    new Component(\n      installationsName,\n      container => {\n        const app = container.getProvider('app').getImmediate();\n\n        // Throws if app isn't configured properly.\n        const appConfig = extractAppConfig(app);\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        const dependencies: FirebaseDependencies = {\n          appConfig,\n          platformLoggerProvider\n        };\n\n        const installations: FirebaseInstallations & FirebaseService = {\n          app,\n          getId: () => getId(dependencies),\n          getToken: (forceRefresh?: boolean) =>\n            getToken(dependencies, forceRefresh),\n          delete: () => deleteInstallation(dependencies),\n          onIdChange: (callback: IdChangeCallbackFn): IdChangeUnsubscribeFn =>\n            onIdChange(dependencies, callback)\n        };\n        return installations;\n      },\n      ComponentType.PUBLIC\n    )\n  );\n\n  instance.registerVersion(name, version);\n}\n\nregisterInstallations(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerInstallations`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    installations(app?: FirebaseApp): FirebaseInstallations;\n  }\n  interface FirebaseApp {\n    installations(): FirebaseInstallations;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createInstallationRequest } from '../api/create-installation-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { generateFid, INVALID_FID } from './generate-fid';\nimport { remove, set, update } from './idb-manager';\n\nexport interface InstallationEntryWithRegistrationPromise {\n  installationEntry: InstallationEntry;\n  /** Exist iff the installationEntry is not registered. */\n  registrationPromise?: Promise<RegisteredInstallationEntry>;\n}\n\n/**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */\nexport async function getInstallationEntry(\n  appConfig: AppConfig\n): Promise<InstallationEntryWithRegistrationPromise> {\n  let registrationPromise: Promise<RegisteredInstallationEntry> | undefined;\n\n  const installationEntry = await update(appConfig, oldEntry => {\n    const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n    const entryWithPromise = triggerRegistrationIfNecessary(\n      appConfig,\n      installationEntry\n    );\n    registrationPromise = entryWithPromise.registrationPromise;\n    return entryWithPromise.installationEntry;\n  });\n\n  if (installationEntry.fid === INVALID_FID) {\n    // FID generation failed. Waiting for the FID from the server.\n    return { installationEntry: await registrationPromise! };\n  }\n\n  return {\n    installationEntry,\n    registrationPromise\n  };\n}\n\n/**\n * Creates a new Installation Entry if one does not exist.\n * Also clears timed out pending requests.\n */\nfunction updateOrCreateInstallationEntry(\n  oldEntry: InstallationEntry | undefined\n): InstallationEntry {\n  const entry: InstallationEntry = oldEntry || {\n    fid: generateFid(),\n    registrationStatus: RequestStatus.NOT_STARTED\n  };\n\n  return clearTimedOutRequest(entry);\n}\n\n/**\n * If the Firebase Installation is not registered yet, this will trigger the\n * registration and return an InProgressInstallationEntry.\n *\n * If registrationPromise does not exist, the installationEntry is guaranteed\n * to be registered.\n */\nfunction triggerRegistrationIfNecessary(\n  appConfig: AppConfig,\n  installationEntry: InstallationEntry\n): InstallationEntryWithRegistrationPromise {\n  if (installationEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n    if (!navigator.onLine) {\n      // Registration required but app is offline.\n      const registrationPromiseWithError = Promise.reject(\n        ERROR_FACTORY.create(ErrorCode.APP_OFFLINE)\n      );\n      return {\n        installationEntry,\n        registrationPromise: registrationPromiseWithError\n      };\n    }\n\n    // Try registering. Change status to IN_PROGRESS.\n    const inProgressEntry: InProgressInstallationEntry = {\n      fid: installationEntry.fid,\n      registrationStatus: RequestStatus.IN_PROGRESS,\n      registrationTime: Date.now()\n    };\n    const registrationPromise = registerInstallation(\n      appConfig,\n      inProgressEntry\n    );\n    return { installationEntry: inProgressEntry, registrationPromise };\n  } else if (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS\n  ) {\n    return {\n      installationEntry,\n      registrationPromise: waitUntilFidRegistration(appConfig)\n    };\n  } else {\n    return { installationEntry };\n  }\n}\n\n/** This will be executed only once for each new Firebase Installation. */\nasync function registerInstallation(\n  appConfig: AppConfig,\n  installationEntry: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  try {\n    const registeredInstallationEntry = await createInstallationRequest(\n      appConfig,\n      installationEntry\n    );\n    return set(appConfig, registeredInstallationEntry);\n  } catch (e) {\n    if (isServerError(e) && e.customData.serverCode === 409) {\n      // Server returned a \"FID can not be used\" error.\n      // Generate a new ID next time.\n      await remove(appConfig);\n    } else {\n      // Registration failed. Set FID as not registered.\n      await set(appConfig, {\n        fid: installationEntry.fid,\n        registrationStatus: RequestStatus.NOT_STARTED\n      });\n    }\n    throw e;\n  }\n}\n\n/** Call if FID registration is pending in another request. */\nasync function waitUntilFidRegistration(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry: InstallationEntry = await updateInstallationRequest(appConfig);\n  while (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n    // createInstallation request still in progress.\n    await sleep(100);\n\n    entry = await updateInstallationRequest(appConfig);\n  }\n\n  if (entry.registrationStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    const {\n      installationEntry,\n      registrationPromise\n    } = await getInstallationEntry(appConfig);\n\n    if (registrationPromise) {\n      return registrationPromise;\n    } else {\n      // if there is no registrationPromise, entry is registered.\n      return installationEntry as RegisteredInstallationEntry;\n    }\n  }\n\n  return entry;\n}\n\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateInstallationRequest(\n  appConfig: AppConfig\n): Promise<InstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!oldEntry) {\n      throw ERROR_FACTORY.create(ErrorCode.INSTALLATION_NOT_FOUND);\n    }\n    return clearTimedOutRequest(oldEntry);\n  });\n}\n\nfunction clearTimedOutRequest(entry: InstallationEntry): InstallationEntry {\n  if (hasInstallationRequestTimedOut(entry)) {\n    return {\n      fid: entry.fid,\n      registrationStatus: RequestStatus.NOT_STARTED\n    };\n  }\n\n  return entry;\n}\n\nfunction hasInstallationRequestTimedOut(\n  installationEntry: InstallationEntry\n): boolean {\n  return (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS &&\n    installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry\n} from '../interfaces/installation-entry';\nimport { PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function generateAuthTokenRequest(\n  { appConfig, platformLoggerProvider }: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers.append('x-firebase-client', platformLogger.getPlatformInfoString());\n  }\n\n  const body = {\n    installation: {\n      sdkVersion: PACKAGE_VERSION\n    }\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: GenerateAuthTokenResponse = await response.json();\n    const completedAuthToken: CompletedAuthToken = extractAuthTokenInfoFromResponse(\n      responseValue\n    );\n    return completedAuthToken;\n  } else {\n    throw await getErrorFromResponse('Generate Auth Token', response);\n  }\n}\n\nfunction getGenerateAuthTokenEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { generateAuthTokenRequest } from '../api/generate-auth-token-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  AuthToken,\n  CompletedAuthToken,\n  InProgressAuthToken,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS, TOKEN_EXPIRATION_BUFFER } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { remove, set, update } from './idb-manager';\n\n/**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */\nexport async function refreshAuthToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<CompletedAuthToken> {\n  let tokenPromise: Promise<CompletedAuthToken> | undefined;\n  const entry = await update(dependencies.appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n      // There is a valid token in the DB.\n      return oldEntry;\n    } else if (oldAuthToken.requestStatus === RequestStatus.IN_PROGRESS) {\n      // There already is a token request in progress.\n      tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);\n      return oldEntry;\n    } else {\n      // No token or token expired.\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      }\n\n      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n      tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);\n      return inProgressEntry;\n    }\n  });\n\n  const authToken = tokenPromise\n    ? await tokenPromise\n    : (entry.authToken as CompletedAuthToken);\n  return authToken;\n}\n\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n *\n * Waits until the current pending request finishes. If the request times out,\n * tries once in this thread as well.\n */\nasync function waitUntilAuthTokenRequest(\n  dependencies: FirebaseDependencies,\n  forceRefresh: boolean\n): Promise<CompletedAuthToken> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry = await updateAuthTokenRequest(dependencies.appConfig);\n  while (entry.authToken.requestStatus === RequestStatus.IN_PROGRESS) {\n    // generateAuthToken still in progress.\n    await sleep(100);\n\n    entry = await updateAuthTokenRequest(dependencies.appConfig);\n  }\n\n  const authToken = entry.authToken;\n  if (authToken.requestStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    return refreshAuthToken(dependencies, forceRefresh);\n  } else {\n    return authToken;\n  }\n}\n\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateAuthTokenRequest(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n      return {\n        ...oldEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n    }\n\n    return oldEntry;\n  });\n}\n\nasync function fetchAuthTokenFromServer(\n  dependencies: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  try {\n    const authToken = await generateAuthTokenRequest(\n      dependencies,\n      installationEntry\n    );\n    const updatedInstallationEntry: RegisteredInstallationEntry = {\n      ...installationEntry,\n      authToken\n    };\n    await set(dependencies.appConfig, updatedInstallationEntry);\n    return authToken;\n  } catch (e) {\n    if (\n      isServerError(e) &&\n      (e.customData.serverCode === 401 || e.customData.serverCode === 404)\n    ) {\n      // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n      // Generate a new ID next time.\n      await remove(dependencies.appConfig);\n    } else {\n      const updatedInstallationEntry: RegisteredInstallationEntry = {\n        ...installationEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n      await set(dependencies.appConfig, updatedInstallationEntry);\n    }\n    throw e;\n  }\n}\n\nfunction isEntryRegistered(\n  installationEntry: InstallationEntry | undefined\n): installationEntry is RegisteredInstallationEntry {\n  return (\n    installationEntry !== undefined &&\n    installationEntry.registrationStatus === RequestStatus.COMPLETED\n  );\n}\n\nfunction isAuthTokenValid(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.COMPLETED &&\n    !isAuthTokenExpired(authToken)\n  );\n}\n\nfunction isAuthTokenExpired(authToken: CompletedAuthToken): boolean {\n  const now = Date.now();\n  return (\n    now < authToken.creationTime ||\n    authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER\n  );\n}\n\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\nfunction makeAuthTokenRequestInProgressEntry(\n  oldEntry: RegisteredInstallationEntry\n): RegisteredInstallationEntry {\n  const inProgressAuthToken: InProgressAuthToken = {\n    requestStatus: RequestStatus.IN_PROGRESS,\n    requestTime: Date.now()\n  };\n  return {\n    ...oldEntry,\n    authToken: inProgressAuthToken\n  };\n}\n\nfunction hasAuthTokenRequestTimedOut(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.IN_PROGRESS &&\n    authToken.requestTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<string> {\n  await completeInstallationRegistration(dependencies.appConfig);\n\n  // At this point we either have a Registered Installation in the DB, or we've\n  // already thrown an error.\n  const authToken = await refreshAuthToken(dependencies, forceRefresh);\n  return authToken.token;\n}\n\nasync function completeInstallationRegistration(\n  appConfig: AppConfig\n): Promise<void> {\n  const { registrationPromise } = await getInstallationEntry(appConfig);\n\n  if (registrationPromise) {\n    // A createInstallation request is in progress. Wait until it finishes.\n    await registrationPromise;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\nimport { RegisteredInstallationEntry } from '../interfaces/installation-entry';\nimport {\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function deleteInstallationRequest(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<void> {\n  const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n  const request: RequestInit = {\n    method: 'DELETE',\n    headers\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (!response.ok) {\n    throw await getErrorFromResponse('Delete Installation', response);\n  }\n}\n\nfunction getDeleteEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { addCallback, removeCallback } from '../helpers/fid-changed';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport type IdChangeCallbackFn = (installationId: string) => void;\nexport type IdChangeUnsubscribeFn = () => void;\n\n/**\n * Sets a new callback that will get called when Installation ID changes.\n * Returns an unsubscribe function that will remove the callback when called.\n */\nexport function onIdChange(\n  { appConfig }: FirebaseDependencies,\n  callback: IdChangeCallbackFn\n): IdChangeUnsubscribeFn {\n  addCallback(appConfig, callback);\n\n  return () => {\n    removeCallback(appConfig, callback);\n  };\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, FirebaseOptions } from '@firebase/app-types';\nimport { FirebaseError } from '@firebase/util';\nimport { AppConfig } from '../interfaces/app-config';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function extractAppConfig(app: FirebaseApp): AppConfig {\n  if (!app || !app.options) {\n    throw getMissingValueError('App Configuration');\n  }\n\n  if (!app.name) {\n    throw getMissingValueError('App Name');\n  }\n\n  // Required app config keys\n  const configKeys: Array<keyof FirebaseOptions> = [\n    'projectId',\n    'apiKey',\n    'appId'\n  ];\n\n  for (const keyName of configKeys) {\n    if (!app.options[keyName]) {\n      throw getMissingValueError(keyName);\n    }\n  }\n\n  return {\n    appName: app.name,\n    projectId: app.options.projectId!,\n    apiKey: app.options.apiKey!,\n    appId: app.options.appId!\n  };\n}\n\nfunction getMissingValueError(valueName: string): FirebaseError {\n  return ERROR_FACTORY.create(ErrorCode.MISSING_APP_CONFIG_VALUES, {\n    valueName\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getId(\n  dependencies: FirebaseDependencies\n): Promise<string> {\n  const { installationEntry, registrationPromise } = await getInstallationEntry(\n    dependencies.appConfig\n  );\n\n  if (registrationPromise) {\n    registrationPromise.catch(console.error);\n  } else {\n    // If the installation is already registered, update the authentication\n    // token if needed.\n    refreshAuthToken(dependencies).catch(console.error);\n  }\n\n  return installationEntry.fid;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deleteInstallationRequest } from '../api/delete-installation-request';\nimport { remove, update } from '../helpers/idb-manager';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport { RequestStatus } from '../interfaces/installation-entry';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport async function deleteInstallation(\n  dependencies: FirebaseDependencies\n): Promise<void> {\n  const { appConfig } = dependencies;\n\n  const entry = await update(appConfig, oldEntry => {\n    if (oldEntry && oldEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n      // Delete the unregistered entry without sending a deleteInstallation request.\n      return undefined;\n    }\n    return oldEntry;\n  });\n\n  if (entry) {\n    if (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n      // Can't delete while trying to register.\n      throw ERROR_FACTORY.create(ErrorCode.DELETE_PENDING_REGISTRATION);\n    } else if (entry.registrationStatus === RequestStatus.COMPLETED) {\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      } else {\n        await deleteInstallationRequest(appConfig, entry);\n        await remove(appConfig);\n      }\n    }\n  }\n}\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.idb = {}));\n}(this, function (exports) { 'use strict';\n\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n      request.onsuccess = function() {\n        resolve(request.result);\n      };\n\n      request.onerror = function() {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function() {\n          return this[targetProp][prop];\n        },\n        set: function(val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', [\n    'name',\n    'keyPath',\n    'multiEntry',\n    'unique'\n  ]);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n    'update',\n    'delete'\n  ]);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function() {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function() {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function(value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, [\n    'deleteIndex'\n  ]);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n      idbTransaction.oncomplete = function() {\n        resolve();\n      };\n      idbTransaction.onerror = function() {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function() {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', [\n    'objectStoreNames',\n    'mode'\n  ]);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, [\n    'abort'\n  ]);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, [\n    'deleteObjectStore',\n    'close'\n  ]);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(DB, '_db', IDBDatabase, [\n    'close'\n  ]);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n    [ObjectStore, Index].forEach(function(Constructor) {\n      // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n      if (!(funcName in Constructor.prototype)) return;\n\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n        request.onsuccess = function() {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function(Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function(query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function(resolve) {\n        instance.iterateCursor(query, function(cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  function openDb(name, version, upgradeCallback) {\n    var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n    var request = p.request;\n\n    if (request) {\n      request.onupgradeneeded = function(event) {\n        if (upgradeCallback) {\n          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n        }\n      };\n    }\n\n    return p.then(function(db) {\n      return new DB(db);\n    });\n  }\n\n  function deleteDb(name) {\n    return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n  }\n\n  exports.openDb = openDb;\n  exports.deleteDb = deleteDb;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"names":["PENDING_TIMEOUT_MS","PACKAGE_VERSION","INTERNAL_AUTH_VERSION","TOKEN_EXPIRATION_BUFFER","ERROR_DESCRIPTION_MAP","_a","ERROR_FACTORY","ErrorFactory","isServerError","error","FirebaseError","code","includes","getInstallationsEndpoint","INSTALLATIONS_API_URL","extractAuthTokenInfoFromResponse","response","token","requestStatus","expiresIn","responseExpiresIn","Number","replace","creationTime","Date","now","getErrorFromResponse","requestName","json","responseJson","errorData","create","serverCode","serverMessage","message","serverStatus","status","getHeaders","apiKey","Headers","Accept","getHeadersWithAuth","appConfig","refreshToken","headers","append","getAuthorizationHeader","retryIfServerError","fn","result","createInstallationRequest","fid","endpoint","body","authVersion","appId","sdkVersion","request","method","JSON","stringify","fetch","_b","ok","responseValue","registrationStatus","authToken","sleep","ms","Promise","resolve","setTimeout","VALID_FID_PATTERN","generateFid","fidByteArray","Uint8Array","self","crypto","msCrypto","getRandomValues","array","btoa","String","fromCharCode","apply","__spreadArray","substr","encode","test","getKey","appName","fidChangeCallbacks","Map","fidChanged","key","callFidChangeCallbacks","channel","getBroadcastChannel","postMessage","closeBroadcastChannel","broadcastFidChange","callbacks","get","callbacks_1_1","callback","broadcastChannel","BroadcastChannel","onmessage","e","data","size","close","instance","OBJECT_STORE_NAME","dbPromise","getDbPromise","openDb","upgradeDB","oldVersion","createObjectStore","set","value","db","tx","transaction","objectStore","oldValue","put","complete","remove","delete","update","updateFn","store","undefined","newValue","getInstallationEntry","oldEntry","installationEntry","clearTimedOutRequest","updateOrCreateInstallationEntry","entryWithPromise","navigator","onLine","registrationPromise","reject","inProgressEntry","registrationTime","registeredInstallationEntry","e_1","customData","registerInstallation","waitUntilFidRegistration","triggerRegistrationIfNecessary","updateInstallationRequest","entry","generateAuthTokenRequest","platformLoggerProvider","getGenerateAuthTokenEndpoint","platformLogger","getImmediate","optional","getPlatformInfoString","installation","refreshAuthToken","dependencies","forceRefresh","isEntryRegistered","oldAuthToken","isAuthTokenExpired","isAuthTokenValid","tokenPromise","updateAuthTokenRequest","waitUntilAuthTokenRequest","inProgressAuthToken","requestTime","makeAuthTokenRequestInProgressEntry","updatedInstallationEntry","fetchAuthTokenFromServer","completeInstallationRegistration","deleteInstallationRequest","getDeleteEndpoint","onIdChange","callbackSet","Set","add","addCallback","removeCallback","getMissingValueError","valueName","firebase","INTERNAL","registerComponent","Component","container","app","getProvider","options","name","configKeys_1_1","keyName","projectId","extractAppConfig","installations","getId","catch","console","getToken","deleteInstallation","registerVersion","version","exports","toArray","arr","Array","prototype","slice","call","promisifyRequest","onsuccess","onerror","promisifyRequestCall","obj","args","p","then","promisifyCursorRequestCall","Cursor","proxyProperties","ProxyClass","targetProp","properties","forEach","prop","Object","defineProperty","this","val","proxyRequestMethods","Constructor","arguments","proxyMethods","proxyCursorRequestMethods","Index","index","_index","cursor","_cursor","_request","ObjectStore","_store","Transaction","idbTransaction","_tx","oncomplete","onabort","UpgradeDB","_db","DB","upgradeCallback","indexedDB","onupgradeneeded","event","deleteDb","IDBIndex","IDBCursor","methodName","createIndex","IDBObjectStore","IDBTransaction","IDBDatabase","funcName","length","nativeObject","getAll","query","count","items","iterateCursor","push","continue","factory"],"sourceRoot":""}